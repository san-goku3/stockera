#for stockera project

# run this from within the terminal
import torch
import torch.nn as nn
from flask import Flask, request, jsonify
import numpy as np
from flask_cors import CORS

app = Flask(__name__)
CORS(app)

# Define your model class
class LSTMModel(nn.Module):
    def __init__(self, input_size, hidden_size, output_size):
        super(LSTMModel, self).__init__()
        self.lstm = nn.LSTM(input_size, hidden_size, num_layers=2, batch_first=True, bidirectional=True)
        self.fc = nn.Linear(hidden_size * 2, output_size)

    def forward(self, x):
        out, _ = self.lstm(x)
        out = self.fc(out[:, -1, :])  # Use output from the last time step
        return out

# Load the trained model
model = LSTMModel(input_size=9, hidden_size=64, output_size=1)
model.load_state_dict(torch.load("e:/majproj/models/best_lstm_model.pth"))
model.eval()

@app.route('/predict', methods=['POST'])
def predict():
    try:
        data = request.get_json()
        companies_data = data.get('data')  # <-- updated key to match frontend

        predictions = []

        for company_data in companies_data:
            company_features = np.array(company_data).reshape(1, 1, 9)
            company_features_tensor = torch.tensor(company_features, dtype=torch.float32)

            # Model prediction
            with torch.no_grad():
                prediction = model(company_features_tensor).item()

            predictions.append(float(prediction))

        return jsonify({"listing_gains": predictions})

    except Exception as e:
        return jsonify({"error": str(e)}), 400

if __name__ == "__main__":
    app.run(debug=True)



#2 sole model streamlit code
#run this from within the terminal
import torch
import torch.nn as nn
from flask import Flask, request, jsonify
import numpy as np
from flask_cors import CORS

app = Flask(__name__)
CORS(app)

# Define your model class (adjusted to match the trained model architecture)
class LSTMModel(nn.Module):
    def __init__(self, input_size, hidden_size, output_size):
        super(LSTMModel, self).__init__()
        self.lstm = nn.LSTM(input_size, hidden_size, num_layers=2, batch_first=True, bidirectional=True)
        self.fc = nn.Linear(hidden_size*2, output_size)

    def forward(self, x):
        out, _ = self.lstm(x)
        out = self.fc(out[:, -1, :])  # Get output from the last time step
        return out

# Initialize the model and load the weights (make sure input_size and hidden_size are as expected)
model = LSTMModel(input_size=9, hidden_size=64, output_size=1)

# Ensure the model architecture matches the one used for training
model.load_state_dict(torch.load("e:/majproj/models/best_lstm_model.pth"))
model.eval()

@app.route('/predict', methods=['POST'])
def predict():
    try:
        # Parse JSON Input
        data = request.json
        companies_data = data['companies']

        predictions = []

        for company_data in companies_data:
            company_features = np.array(company_data).reshape(1, 1, 9)
            company_features_tensor = torch.tensor(company_features, dtype=torch.float32)

            # Make Prediction
            with torch.no_grad():
                prediction = model(company_features_tensor).item()  # Get the predicted value

            predictions.append(float(prediction))

        return jsonify({"listing_gains": predictions})

    except Exception as e:
        return jsonify({"error": str(e)}), 400

if __name__ == "__main__":
    app.run(debug=True)
